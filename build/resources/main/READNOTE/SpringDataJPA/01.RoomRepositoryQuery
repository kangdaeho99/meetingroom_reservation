QueryDSL 을 사용하여 한 모습 : https://cafe.naver.com/gugucoding/7391

pg305, pg372
/**
 * Mysql 특징으로 RoomImage를 사용할시 에러. QueryDSL으로 대체
 */

에러가 난다.
@Query("select room, roomImage, avg(coalesce(review.grade, 0)), count(distinct review) from Room room" +
        " left outer join RoomImage roomImage on roomImage.room = room" +
        " left outer join Review review on review.room = room group by room")
Page<Object[]> getListPage(Pageable pageable);


이렇게 할경우 10개를 뽑으면 이미지와 함꼐 뽑히기에 글도 5개 뽑히고 이미지도 5개 뽑힌다.
@Query("select room, roomImage, avg(coalesce(review.grade, 0)), count(distinct review) from Room room" +
        " left outer join RoomImage roomImage on roomImage.room = room" +
        " left outer join Review review on review.room = room group by room, roomImage")
Page<Object[]> getListPage(Pageable pageable);



이것도 마찬가지
@Query("select room, roomImage.uuid, avg(coalesce(review.grade, 0)), count(distinct review) from Room room" +
" left outer join RoomImage roomImage on roomImage.room = room" +
" left outer join Review review on review.room = room group by room, roomImage.imgName")




카페공식글보고 해봤는데 한개만 나온다 : https://cafe.naver.com/gugucoding/6255
여기서 query.groupBy(room)을 주석처리하면 여러개 나오는데 글도 여러개 나와서안된다.

    @Log4j2
    public class RoomQueryDslRepositoryImpl extends QuerydslRepositorySupport implements RoomQueryDslRepository {

        public RoomQueryDslRepositoryImpl() {
            super(Room.class);
        }

        @Override
        public Page<Object[]> getListPage(Pageable pageable) {
            QRoom room = QRoom.room;
            QReview review = QReview.review;
            QRoomImage roomImage = QRoomImage.roomImage;

            JPQLQuery<RoomImage> query = from(roomImage);
            query.leftJoin(room).on(room.eq(roomImage.room));
            JPQLQuery<Tuple> tuple = query
                    .select(room, roomImage,
                            JPAExpressions.select(review.countDistinct()).from(review).where(review.room.eq(roomImage.room)),
                            JPAExpressions.select(review.grade.avg()).from(review).where(review.room.eq(roomImage.room))
                    )
                    .where(roomImage.inum.in(JPAExpressions.select(roomImage.inum.min()).from(roomImage).where(room.eq(roomImage.room))
                            .groupBy(room, roomImage.room))
                    ).orderBy(room.rno.desc());

            tuple = this.getQuerydsl().applyPagination(pageable, tuple);
            List<Tuple> result = tuple.fetch();
            long count = tuple.fetchCount();
            List<Object[]> collect = result.stream().map(t -> {
                Object[] arr = t.toArray();
                log.info(Arrays.toString(arr));
                return arr;
            } ).collect(Collectors.toList());

            return new PageImpl<>(collect, pageable, count);



        }
    }



create table review (reviewnum bigint generated by default as identity, grade integer not null, text varchar(255), member_mid bigint, room_rno bigint, primary key (reviewnum))
create table room (rno bigint generated by default as identity, moddate timestamp(6), regdate timestamp(6), content varchar(255), title varchar(255), primary key (rno))
create table room_image (inum bigint generated by default as identity, img_name varchar(255), path varchar(255), uuid varchar(255), room_rno bigint, primary key (inum))

이렇게 room, room_image, review 테이블이 있어
여기서 데이터는 room에 room_image가 1:N 관계이고
room과 review는 N:M 관계야

room의 정보와 room_image와 연관된 가장 최신값 이 2가지를 엮어서 sql코드 짜줘

SELECT r.*, ri.*
FROM room r
LEFT JOIN (
  SELECT ri1.*
  FROM room_image ri1
  WHERE ri1.inum = (
    SELECT MIN(ri2.inum)
    FROM room_image ri2
    WHERE ri2.room_rno = ri1.room_rno
  )
) ri ON r.rno = ri.room_rno;
위 쿼리는 "room"과 "room_image" 테이블을 "LEFT JOIN"으로 결합하여,
"room_image" 테이블에서 각 방별로 가장 최신 "inum" 값을 가진 레코드를 가져옵니다.
"room"과 "room_image" 테이블에서 가져온 열은 모두 반환되므로,
반환되는 열은 "room" 테이블의 모든 열과 "room_image" 테이블의 모든 열입니다.

일단 room과 room_image를 연관지어서 paging까지 해봅니다.

SELECT r.*, ri.uuid, COALESCE(avg_review_grade, 0), COALESCE(cnt_reviews, 0)
FROM room r
LEFT JOIN (
  SELECT ri1.*
  FROM room_image ri1
  WHERE ri1.inum = (
    SELECT MIN(ri2.inum)
    FROM room_image ri2
    WHERE ri2.room_rno = ri1.room_rno
  )
) ri ON r.rno = ri.room_rno
LEFT JOIN (
  SELECT room_rno, COALESCE(avg(grade), 0) as avg_review_grade, count(DISTINCT reviewnum) as cnt_reviews
  FROM review
  GROUP BY room_rno
) rv ON r.rno = rv.room_rno;


해당 쿼리는 다음과 같은 구성으로 이루어져 있습니다.

FROM 구문
room과 room_image, review 테이블들이 사용됩니다.
SELECT 구문
room 테이블의 모든 컬럼 (r.*)과 room_image 테이블의 uuid 컬럼이 선택됩니다.
COALESCE 함수를 사용하여, 해당 방의 평균 평점과 리뷰 개수를 선택합니다.
COALESCE 함수는 인자로 받은 값 중에서 NULL이 아닌 첫 번째 값을 반환합니다.
따라서, 해당 방에 대한 리뷰가 없는 경우에는 0이 반환됩니다.
이후, LEFT JOIN을 사용하여 room_image와 review 테이블을 room 테이블과 연결합니다.
room_image 테이블과 review 테이블은 각각 1:N, N:M 관계를 가지므로, LEFT JOIN을 사용하여 연결합니다.
LEFT JOIN을 사용하면, room 테이블의 모든 레코드를 기준으로 room_image와 review 테이블을 연결합니다.
따라서, 해당 방에 대한 이미지나 리뷰가 없는 경우에도 결과에 나타나게 됩니다.
GROUP BY 구문
GROUP BY 구문을 사용하여, 방에 대한 리뷰의 평균 평점과 리뷰 개수를 계산합니다.
GROUP BY 구문을 사용하여, room_rno 컬럼을 기준으로 그룹핑합니다.
COUNT(DISTINCT reviewnum) 구문을 사용하여, 중복되지 않는 리뷰 개수를 계산합니다.





@Query("SELECT room, roomImage FROM Room room" +
        "LEFT OUTER JOIN RoomImage roomImage on roomImage.room = room"
        )
List<Object[]> getListPage(Pageable pageable);
이렇게 할경우 이렇게 나온다. 여기서 group by를 할경우
[Room(rno=3, title=Title...3, content=Content...3), RoomImage(inum=15, uuid=8539f909-5276-4042-ac70-9efc02f46631, imgName=test4.jpg, path=null)]
[Room(rno=4, title=Title...4, content=Content...4), RoomImage(inum=16, uuid=d35540c2-2f25-4c2f-9902-004896760253, imgName=test0.jpg, path=null)]
[Room(rno=4, title=Title...4, content=Content...4), RoomImage(inum=17, uuid=6ee0d47e-9da1-4db5-8df4-8179a4dee1bb, imgName=test1.jpg, path=null)]
[Room(rno=4, title=Title...4, content=Content...4), RoomImage(inum=18, uuid=87e6f807-d79d-4cc4-b5eb-b9722c5d547c, imgName=test2.jpg, path=null)]
[Room(rno=4, title=Title...4, content=Content...4), RoomImage(inum=19, uuid=8316082f-4054-4b1f-83f1-5027befed4fe, imgName=test3.jpg, path=null)]
[Room(rno=5, title=Title...5, content=Content...5), RoomImage(inum=20, uuid=204c8514-676b-4470-9528-8b44c9d24159, imgName=test0.jpg, path=null)]
[Room(rno=5, title=Title...5, content=Content...5), RoomImage(inum=21, uuid=1464ab7f-50dd-4d35-8b32-81abdf511177, imgName=test1.jpg, path=null)]
[Room(rno=7, title=Title...7, content=Content...7), RoomImage(inum=28, uuid=1ab288d3-8c45-44d9-a7a2-2988670e7d17, imgName=test2.jpg, path=null)]
[Room(rno=5, title=Title...5, content=Content...5), RoomImage(inum=22, uuid=fa5edd6a-bea6-4cc9-b6b0-0797e1c16696, imgName=test2.jpg, path=null)]
[Room(rno=7, title=Title...7, content=Content...7), RoomImage(inum=26, uuid=386e9a62-27ad-4e27-9ad4-1642cb4d023e, imgName=test0.jpg, path=null)]


sql먼저 짜보기
select room.*, room_image.* from Room as room
left join Room_Image as room_image on room_image.room_rno = room.rno;
를 할경우 전체가 나옵니다. 여기서 group by roo.rno를 할려고했는데 그렇게할경우
aggregated column이 나오면서(group by 하면 1:N 관계이기 떄문에 몇가지가 집계가 안되서?
오류가 나옵니다.)

SELECT room.*, room_image.* FROM Room as room
LEFT JOIN ( SELECT room_image1.* FROM room_image room_image1 WHERE room_image1.inum = (
SELECT MIN(room_image2.inum) FROM room_image room_image2 WHERE room_image2.room_rno = room_image1.room_rno)
) room_image ON room.rno = room_image.room_rno
GROUP BY room.rno, room_image.inum;
(페이징 처리 할시 LIMIT 10 OFFSET 0; 를 추가)
이렇게 하면 결과가 잘 나옵니다. 이제 이렇게까지만 한 결과를 JPQL로 변환시켜봅니다.
다만,


@Override
    public Page<Object[]> getListPage(Pageable pageable) {
            QRoom room = QRoom.room;
            QRoomImage roomImage = QRoomImage.roomImage;

            JPQLQuery<Room> jpqlQuery = from(room);
            jpqlQuery.leftJoin(roomImage).on(roomImage.room.eq(room));


            JPQLQuery<Tuple> tuple = jpqlQuery.select(
                    room,
                    roomImage.uuid
            ).where(
                    roomImage.inum.eq(
                            select(roomImage.inum.min()).from(roomImage).where(roomImage.room.rno.eq(room.rno))
                    )
            );

//        tuple.orderBy(roomImage.inum.desc());

        log.info("---------------");
        log.info(tuple);
        log.info("---------------");
        this.getQuerydsl().applyPagination(pageable, tuple);
        List<Tuple> result = tuple.fetch();
//        log.info(result);
        for(int i=0;i<result.size();i++){
            System.out.println(result.get(i));
        }
        return null;

    }

 이렇게 하면 될줄알았는데 되지않는다. 이유는 roomImage에서 최소값을 가져오기 떄문에 1개만 나오는것이다.


해결방안 찾았다. 결론은 sql코드에서는 roomImage에 대하여 roomImage1, roomImage2 이렇게 2개의
별칭을 사용하여 진행하여 각각의 연산을 진행했는데

@Override
    public Page<Object[]> getListPage(Pageable pageable) {
            QRoom room = QRoom.room;
            QRoomImage roomImage = QRoomImage.roomImage;
            QRoomImage roomImage2 = new QRoomImage("roomImage2");

            JPQLQuery<Room> jpqlQuery = from(room);
            jpqlQuery.leftJoin(roomImage).on(room.eq(roomImage.room));

            JPQLQuery<Tuple> tuple = jpqlQuery.select(
                    room,
                    roomImage.uuid
            ).where(
                    roomImage.inum.in(
                            select(roomImage2.inum.min()).from(roomImage2).where(roomImage2.room.eq(room))
                    )
            );



//        tuple.orderBy(roomImage.inum.desc());

        log.info("---------------");
        log.info(tuple);
        log.info("---------------");
        this.getQuerydsl().applyPagination(pageable, tuple);
        List<Tuple> result = tuple.fetch();
//        log.info(result);
        for(int i=0;i<result.size();i++){
            System.out.println(result.get(i));
        }
        return null;

    }

이렇게 roomImage2를 새로운 별칭 roomImage2로 해야한다.
처음에 QRoomImage roomImage2 = QRoomImage.roomImage;
이렇게하면 같은 별칭으로 인식된다고한다.

(또 아래처럼 SubQueryExpression을 활용하여할 수 있는데 어처피 Q객체를 생성해서 하는것이 더 나아보인다.)
QRoom room = QRoom.room;
QRoomImage roomImage = QRoomImage.roomImage;

JPQLQuery<Tuple> jpqlQuery = from(room)
        .leftJoin(roomImage).on(room.eq(roomImage.room))
        .select(room, roomImage.uuid);

SubQueryExpression<Long> subQuery = JPAExpressions.select(roomImage.inum.min())
        .from(roomImage)
        .where(roomImage.room.eq(room));

jpqlQuery.where(roomImage.inum.eq(subQuery));

return QuerydslUtil.paging(pageable, jpqlQuery);


그러나 위에처럼 할시 하나의 Room 당 몇번씩 계속해서 발생하므로
select r.*, ri.*
from Room r
left join Room_Image ri on r.rno = ri.room_rno
where ri.inum = (
  select min(ri2.inum)
  from Room_Image ri2
  where ri2.room_rno = r.rno
)
이것처럼 각각의 r.rno에 대해서 한번만 실행하는 쿼리로 바꾼다.
차이점은 이전에는 roominage2.room_rno = roomImage1.room_rno였고 이제는
where ri2.room_rno = r.rno 라는 것이다.
또 이전에는 roomimage를 다 구한다음에 roomImage와 다른 roomImage의 room_rno가 같은것들중
최소값을 찾아서 room_image를 두번 돌았다. 그러나 위의 것은 leftjoin을 통해 다 구한뒤
해당하는 ri.inum을 남기는것이다.


Querydsl 코드이다.
jpaQuery<>(getEntityManager)를 활용하여 진행햇다.

@Override
    public Page<Object[]> getListPage(Pageable pageable) {
            QRoom room = QRoom.room;
            QRoomImage roomImage = QRoomImage.roomImage;
            QRoomImage roomImage2 = new QRoomImage("roomImage2");

            JPQLQuery<Tuple> jpqlQuery = new JPAQuery<>(getEntityManager());

            JPQLQuery<Tuple> tuple = jpqlQuery.select(
                    room,
                    roomImage.uuid
            ).from(room)
            .leftJoin(roomImage).on(room.eq(roomImage.room))
            .where(
                    roomImage.inum.eq(
                            select(roomImage2.inum.min()).from(roomImage2).where(room.eq(roomImage2.room))
                    )
            );



//        tuple.orderBy(roomImage.inum.desc());

        log.info("---------------");
        log.info(tuple);
        log.info("---------------");
        this.getQuerydsl().applyPagination(pageable, tuple);
        List<Tuple> result = tuple.fetch();
//        log.info(result);
        for(int i=0;i<result.size();i++){
            System.out.println(result.get(i));
        }
        return null;

    }

------------------------
이제 댓글의 개수, 평균을
왜 여기서 groupBy를 해야 작동해?
이전에 알려줬던
.and(review.room.eq(room)) // 특정 룸에 대한 리뷰 수 가져오기 이거는 작동안하고?

그 이유는 countDistinct 함수가 특정 룸에 대한 리뷰 수를 가져오려면 그룹화(groupBy)가 필요하기 때문입니다. countDistinct 함수를 사용하면 중복되지 않은 데이터의 수를 가져오기 때문에, 특정 룸에 대한 리뷰 수를 가져오려면 해당 룸을 기준으로 그룹화를 해주어야 합니다.

이에 반해, review.room.eq(room)은 단순히 review 엔티티와 room 엔티티의 관계를 설정해주는 것이므로, countDistinct 함수와는 직접적인 연관이 없기 때문에 작동하지 않습니다.

------
우선 집계함수 사용시 group By를 사용핸다는것.

그리고 roomImage가 없을시 room이 안나오는결과가 있었는데
.or(roomImage.isNull()) 도 추가하여 해결.
coalesce가 작동안해서 case로 진행하였는데
new CaseBuilder()
        .when(review.grade.avg().isNull()).then(0.0)
        .otherwise(review.grade.avg()),
여기서 신기한점은 then(0.0) 이렇게 review.grade.avg의 타입을 맞춰줘야 작동한다.
만약 then(0)이라면 .otherwise는 double인데 int이므로 오류가난ㄷ.


    @Override
    public Page<Object[]> getListPage(Pageable pageable) {
            QRoom room = QRoom.room;
            QRoomImage roomImage = QRoomImage.roomImage;
            QRoomImage roomImage2 = new QRoomImage("roomImage2");
            QReview review = QReview.review;

            JPQLQuery<Tuple> jpqlQuery = new JPAQuery<>(getEntityManager());

            JPQLQuery<Tuple> tuple = jpqlQuery.select(
                    room,
                    roomImage.uuid,
//                    coalesce(review.grade.avg(), 0),
                    new CaseBuilder()
                            .when(review.grade.avg().isNull()).then(0.0)
                            .otherwise(review.grade.avg()),
//                    review.grade.avg().coalesceNull(0,0),
                    review.countDistinct()
            ).from(room)
            .leftJoin(roomImage).on(room.eq(roomImage.room))
            .leftJoin(review).on(room.eq(review.room))
            .where(
                    roomImage.inum.eq(
                            select(roomImage2.inum.min()).from(roomImage2).where(room.eq(roomImage2.room))
                    ).or(roomImage.isNull())

            ).groupBy(room);


--------------------------------------------

자 갑자기 이유는 모르겠으나 원래

@Override
    public Page<Object[]> searchPageWithImageReplyReview(String type, String keyword, Pageable pageable) {
        log.info("searchPage..........");
        QRoom room = QRoom.room;
        QMember member = QMember.member;
        QRoomImage roomImage = QRoomImage.roomImage;
        QRoomImage roomImage2 = new QRoomImage("roomImage2");
        QReply reply = QReply.reply;
        QReview review = QReview.review;

        JPQLQuery<Room> jpqlQuery = from(room);
        jpqlQuery.leftJoin(member).on(room.writer.eq(member));
        jpqlQuery.leftJoin(roomImage).on(room.eq(roomImage.room));
        jpqlQuery.leftJoin(reply).on(reply.room.eq(room));
        jpqlQuery.leftJoin(review).on(room.eq(review.room));
        jpqlQuery.where(roomImage.inum.eq(
                select(roomImage2.inum.min()).from(roomImage2).where(room.eq(roomImage2.room))
                ).or(roomImage.isNull())
        ).groupBy(room, roomImage);

        JPQLQuery<Tuple> tuple = jpqlQuery.select(room,
                member,
                roomImage.uuid,
                reply.count(),
                new CaseBuilder()
                        .when(review.grade.avg().isNull()).then(0.0)
                        .otherwise(review.grade.avg()),
                review.countDistinct()
        );

        BooleanBuilder booleanBuilder = new BooleanBuilder();
        BooleanExpression expression = room.rno.gt(0L);

        booleanBuilder.and(expression);

        if(type!=null){
            String[] typeArr = type.split("");
            BooleanBuilder conditionBuilder = new BooleanBuilder();
            for(String t:typeArr){
                switch(t){
                    case "t":
                        conditionBuilder.or(room.title.contains(keyword));
                        break;
                    case "w":
                        conditionBuilder.or(member.email.contains(keyword));
                        break;
                    case "c":
                        conditionBuilder.or(room.content.contains(keyword));
                        break;
                }
            }
            booleanBuilder.and(conditionBuilder);
        }
        tuple.where(booleanBuilder);

//        Sort sort = pageable.getSort();
//        sort.stream().forEach(order -> {
//            Order direction = order.isAscending() ? Order.ASC : Order.DESC;
//            String prop = order.getProperty();
//
//            PathBuilder orderByExpression = new PathBuilder(Room.class, "room");
//            tuple.orderBy(new OrderSpecifier<>(direction, orderByExpression.get(prop)));
//        });
//        tuple.groupBy(room);
//
//        //page 처리
//        tuple.offset(pageable.getOffset());
//        tuple.limit(pageable.getPageSize());

//        tuple.groupBy(room);
        Objects.requireNonNull(this.getQuerydsl()).applyPagination(pageable, tuple);
        List<Tuple> result = tuple.fetch();
        log.info(result);
        long count = tuple.fetchCount();
        log.info("COUNT: " +count);
        List<Object[]> collect = result.stream().map(t ->{
            Object[] arr = t.toArray();
            log.info(Arrays.toString(arr));
            return arr;
        }).collect(Collectors.toList());
        return new PageImpl<Object[]>(
                collect,
                pageable,
                count);
    }